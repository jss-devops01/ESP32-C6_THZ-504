defaults:
  icon: "mdi:lightning-bolt"
  accuracy_decimals: "2"
  target: "Kessel"

globals:
  - id: gOFFSET_${property_wh}
    type: float
    restore_value: yes
    initial_value: "0.0"

sensor:
  - platform: template
    name: ${property_wh}
    id: ${property_wh}
    state_class: "measurement"
    accuracy_decimals: 3
    internal: true
    update_interval: never
    filters:
      - multiply: 0.001
      - lambda: |-
          return x - id(gOFFSET_${property_wh});

  - platform: template
    name: ${sensor_name}
    id: ${sensor_name}
    unit_of_measurement: "kWh"
    icon: ${icon}
    accuracy_decimals: ${accuracy_decimals}
    device_class: energy
    state_class: total_increasing
    update_interval: never

esphome:
  on_boot:
    priority: 100.0 # AFTER_CONNECTION
    then:
      - lambda: |-
          // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.
          CallbackHandler::instance().addCallback(std::make_pair(${target},Property::k${property_wh}),[](const SimpleVariant& value){
            id(${property_wh}).publish_state(value.get<std::uint16_t>());
          });
          CallbackHandler::instance().addCallback(std::make_pair(${target},Property::k${property_kwh}),[](const SimpleVariant& value){
            id(${sensor_name}).publish_state(value.get<std::uint16_t>() + id(${property_wh}).state);
          });
          // initial queueing of the Wh and kWh value
          queueRequest(${target}, Property::k${property_wh});
          queueRequest(${target}, Property::k${property_kwh});

# Time-based energy calculations are handled by the main sntp_time platform in common.yaml
