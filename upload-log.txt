
[2025-09-28 23:07:20] Starting ESPHome direct upload process...
[2025-09-28 23:07:20] Project path: C:\dev\repos\OneESP32ToRuleThemAll
[2025-09-28 23:07:20] Config file:  esp32-c6-thz504.yaml
[2025-09-28 23:07:20] Device IP:    192.168.200.80
[2025-09-28 23:07:21] ESPHome found: Version: 2025.5.1
[2025-09-28 23:07:21] Starting compilation of esp32-c6-thz504.yaml...
[2025-09-28 23:07:21] Running: esphome compile esp32-c6-thz504.yaml
[2025-09-28 23:07:22] Compilation failed!
[2025-09-28 23:07:22] Error output: INFO ESPHome 2025.5.1 INFO Reading configuration esp32-c6-thz504.yaml... WARNING GPIO8 is a strapping PIN and should only be used for I/O with care. Attaching external pullup/down resistors to strapping pins can cause unexpected failures. See https://esphome.io/guides/faq.html#why-am-i-getting-a-warning-about-strapping-pins Failed config  esphome: None   includes:      - src/callback_handler.h     - src/communication.h     - src/mapper.h     - src/mapper.cpp     - src/property.h     - src/property.cpp     - src/simple_variant.h     - src/type.h     - src/type.cpp     - src/util.h     - src/custom_climate.h   platformio_options:      build_flags:        - -DESPCLIENT_ID=0x6a2       - -DMANAGER_ID=0x6a1       - -DKESSEL_ID=0x180       - -DHK1_ID=0x301       - -DHK2_ID=0x302       - -DTHZ_504       - -std=gnu++2a     build_unflags:        - -std=gnu++11       - -fno-rtti   on_boot:  [source yaml\wp_temperature.yaml:23]     - [source yaml\wp_temperature.yaml:23]       priority: -100.0       then:  [source yaml\wp_temperature.yaml:25]         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(EXHAUST_AIR_TEMP).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEXHAUST_AIR_TEMP),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kEXHAUST_AIR_TEMP),callback);             }             queueRequest(Kessel, Property::kEXHAUST_AIR_TEMP);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(STORAGE_TEMP_SETPOINT_DAY).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSTORAGE_TEMP_SETPOINT_DAY),callback);             if constexpr(true) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kSTORAGE_TEMP_SETPOINT_DAY),callback);             }             queueRequest(Kessel, Property::kSTORAGE_TEMP_SETPOINT_DAY);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(STORAGE_TEMP_SETPOINT_NIGHT).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSTORAGE_TEMP_SETPOINT_NIGHT),callback);             if constexpr(true) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kSTORAGE_TEMP_SETPOINT_NIGHT),callback);             }             queueRequest(Kessel, Property::kSTORAGE_TEMP_SETPOINT_NIGHT);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(COLLECTOR_TEMP_ACTUAL).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kCOLLECTOR_TEMP_ACTUAL),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kCOLLECTOR_TEMP_ACTUAL),callback);             }             queueRequest(Kessel, Property::kCOLLECTOR_TEMP_ACTUAL);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(DEWPOINT_HC1).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kDEWPOINT_HC1),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kDEWPOINT_HC1),callback);             }             queueRequest(HK1, Property::kDEWPOINT_HC1);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(ROOM_TEMP_SETPOINT_DAY).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kROOM_TEMP_SETPOINT_DAY),callback);             if constexpr(true) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kROOM_TEMP_SETPOINT_DAY),callback);             }             queueRequest(HK1, Property::kROOM_TEMP_SETPOINT_DAY);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(ROOM_TEMP_SETPOINT_NIGHT).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kROOM_TEMP_SETPOINT_NIGHT),callback);             if constexpr(true) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kROOM_TEMP_SETPOINT_NIGHT),callback);             }             queueRequest(HK1, Property::kROOM_TEMP_SETPOINT_NIGHT);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(COOLING_ROOM_SETPOINT_DAY).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kCOOLING_ROOM_SETPOINT_DAY),callback);             if constexpr(true) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kCOOLING_ROOM_SETPOINT_DAY),callback);             }             queueRequest(HK1, Property::kCOOLING_ROOM_SETPOINT_DAY);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(EVAPORATOR_TEMP).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEVAPORATOR_TEMP),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kEVAPORATOR_TEMP),callback);             }             queueRequest(Kessel, Property::kEVAPORATOR_TEMP);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_LEVEL_DAY),                                                      std::make_pair(Manager,Property::kVENT_LEVEL_DAY)},[](const SimpleVariant& value){                 const auto fan_speed = std::min(static_cast<std::uint16_t>(3U),static_cast<std::uint16_t>(value));                 // only speeds between 1 and speed_count are allowed                 if(fan_speed == 0) {                   id(VENT_LEVEL_DAY).turn_off().perform();                 } else {                   id(VENT_LEVEL_DAY).turn_on().set_speed(fan_speed).perform();                 }             });             queueRequest(Kessel, Property::kVENT_LEVEL_DAY);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_LEVEL_NIGHT),                                                      std::make_pair(Manager,Property::kVENT_LEVEL_NIGHT)},[](const SimpleVariant& value){                 const auto fan_speed = std::min(static_cast<std::uint16_t>(3U),static_cast<std::uint16_t>(value));                 // only speeds between 1 and speed_count are allowed                 if(fan_speed == 0) {                   id(VENT_LEVEL_NIGHT).turn_off().perform();                 } else {                   id(VENT_LEVEL_NIGHT).turn_on().set_speed(fan_speed).perform();                 }             });             queueRequest(Kessel, Property::kVENT_LEVEL_NIGHT);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_LEVEL_PARTY),                                                      std::make_pair(Manager,Property::kVENT_LEVEL_PARTY)},[](const SimpleVariant& value){                 const auto fan_speed = std::min(static_cast<std::uint16_t>(3U),static_cast<std::uint16_t>(value));                 // only speeds between 1 and speed_count are allowed                 if(fan_speed == 0) {                   id(VENT_LEVEL_PARTY).turn_off().perform();                 } else {                   id(VENT_LEVEL_PARTY).turn_on().set_speed(fan_speed).perform();                 }             });             queueRequest(Kessel, Property::kVENT_LEVEL_PARTY);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEXHAUST_AIR_HUMIDITY),[](const SimpleVariant& value){                 id(EXHAUST_AIR_HUMIDITY).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kEXHAUST_AIR_HUMIDITY);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kMOTORSTROM),[](const SimpleVariant& value){                 id(MOTORSTROM).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kMOTORSTROM);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kMOTORSPANNUNG),[](const SimpleVariant& value){                 id(MOTORSPANNUNG).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kMOTORSPANNUNG);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kMOTOR_POWER),[](const SimpleVariant& value){                 id(MOTOR_POWER).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kMOTOR_POWER);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kCOMPRESSOR_SPEED),[](const SimpleVariant& value){                 id(COMPRESSOR_SPEED).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kCOMPRESSOR_SPEED);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kHEIZLEISTUNG_RELATIV),[](const SimpleVariant& value){                 id(HEIZLEISTUNG_RELATIV).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kHEIZLEISTUNG_RELATIV);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kHEIZ_KUEHL_LEISTUNG),[](const SimpleVariant& value){                 id(HEIZ_KUEHL_LEISTUNG).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kHEIZ_KUEHL_LEISTUNG);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEXHAUST_AIR_ACTUAL),[](const SimpleVariant& value){                 id(EXHAUST_AIR_ACTUAL).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kEXHAUST_AIR_ACTUAL);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kOUTDOOR_AIR_ACTUAL),[](const SimpleVariant& value){                 id(OUTDOOR_AIR_ACTUAL).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kOUTDOOR_AIR_ACTUAL);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSUPPLY_AIR_ACTUAL),[](const SimpleVariant& value){                 id(SUPPLY_AIR_ACTUAL).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kSUPPLY_AIR_ACTUAL);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEXHAUST_AIR_SETPOINT),[](const SimpleVariant& value){                 id(EXHAUST_AIR_SETPOINT).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kEXHAUST_AIR_SETPOINT);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kOUTDOOR_AIR_SETPOINT),[](const SimpleVariant& value){                 id(OUTDOOR_AIR_SETPOINT).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kOUTDOOR_AIR_SETPOINT);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSUPPLY_AIR_SETPOINT),[](const SimpleVariant& value){                 id(SUPPLY_AIR_SETPOINT).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kSUPPLY_AIR_SETPOINT);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kVOLUME_FLOW),[](const SimpleVariant& value){                 id(VOLUME_FLOW).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kVOLUME_FLOW);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kLAUFZEIT_FILTER),[](const SimpleVariant& value){                 id(LAUFZEIT_FILTER).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kLAUFZEIT_FILTER);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kANZEIGE_NIEDERDRUCK),[](const SimpleVariant& value){                 id(ANZEIGE_NIEDERDRUCK).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kANZEIGE_NIEDERDRUCK);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kPUMPENZYKLEN_MIN_AUSSENT),[](const SimpleVariant& value){                 id(PUMPENZYKLEN_MIN_AUSSENT).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kPUMPENZYKLEN_MIN_AUSSENT);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kSETPOINT_MAX_HC1),[](const SimpleVariant& value){                 id(SETPOINT_MAX_HC1).publish_state(1.0 * value.get<float>());             });             queueRequest(HK1, Property::kSETPOINT_MAX_HC1);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kSETPOINT_MIN_HC1),[](const SimpleVariant& value){                 id(SETPOINT_MIN_HC1).publish_state(1.0 * value.get<float>());             });             queueRequest(HK1, Property::kSETPOINT_MIN_HC1);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kFLOW_SHARE_HC1),[](const SimpleVariant& value){                 id(FLOW_SHARE_HC1).publish_state(1.0 * value.get<float>());             });             queueRequest(HK1, Property::kFLOW_SHARE_HC1);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kBASE_POINT_HC1),[](const SimpleVariant& value){                 id(BASE_POINT_HC1).publish_state(1.0 * value.get<float>());             });             queueRequest(HK1, Property::kBASE_POINT_HC1);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kNE_STUFE_WW),                                                       std::make_pair(Manager,Property::kNE_STUFE_WW)},[](const SimpleVariant& value){                 id(NE_STUFE_WW).publish_state(value);             });             queueRequest(Kessel, Property::kNE_STUFE_WW);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kLEISTUNG_AUSLEGUNG_HEIZUNG),                                                       std::make_pair(Manager,Property::kLEISTUNG_AUSLEGUNG_HEIZUNG)},[](const SimpleVariant& value){                 id(LEISTUNG_AUSLEGUNG_HEIZUNG).publish_state(value);             });             queueRequest(Kessel, Property::kLEISTUNG_AUSLEGUNG_HEIZUNG);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kLEISTUNG_AUSLEGUNG_KUEHLEN),                                                       std::make_pair(Manager,Property::kLEISTUNG_AUSLEGUNG_KUEHLEN)},[](const SimpleVariant& value){                 id(LEISTUNG_AUSLEGUNG_KUEHLEN).publish_state(value);             });             queueRequest(Kessel, Property::kLEISTUNG_AUSLEGUNG_KUEHLEN);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kPUMPENDREHZAHL_HEIZEN),                                                       std::make_pair(Manager,Property::kPUMPENDREHZAHL_HEIZEN)},[](const SimpleVariant& value){                 id(PUMPENDREHZAHL_HEIZEN).publish_state(value);             });             queueRequest(Kessel, Property::kPUMPENDREHZAHL_HEIZEN);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kHYSTERESE_WW),                                                       std::make_pair(Manager,Property::kHYSTERESE_WW)},[](const SimpleVariant& value){                 id(HYSTERESE_WW).publish_state(value);             });             queueRequest(Kessel, Property::kHYSTERESE_WW);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_SUPPLY_LEVEL1),                                                       std::make_pair(Manager,Property::kVENT_SUPPLY_LEVEL1)},[](const SimpleVariant& value){                 id(VENT_SUPPLY_LEVEL1).publish_state(value);             });             queueRequest(Kessel, Property::kVENT_SUPPLY_LEVEL1);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_SUPPLY_LEVEL2),                                                       std::make_pair(Manager,Property::kVENT_SUPPLY_LEVEL2)},[](const SimpleVariant& value){                 id(VENT_SUPPLY_LEVEL2).publish_state(value);             });             queueRequest(Kessel, Property::kVENT_SUPPLY_LEVEL2);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_SUPPLY_LEVEL3),                                                       std::make_pair(Manager,Property::kVENT_SUPPLY_LEVEL3)},[](const SimpleVariant& value){                 id(VENT_SUPPLY_LEVEL3).publish_state(value);             });             queueRequest(Kessel, Property::kVENT_SUPPLY_LEVEL3);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_EXHAUST_LEVEL1),                                                       std::make_pair(Manager,Property::kVENT_EXHAUST_LEVEL1)},[](const SimpleVariant& value){                 id(VENT_EXHAUST_LEVEL1).publish_state(value);             });             queueRequest(Kessel, Property::kVENT_EXHAUST_LEVEL1);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_EXHAUST_LEVEL2),                                                       std::make_pair(Manager,Property::kVENT_EXHAUST_LEVEL2)},[](const SimpleVariant& value){                 id(VENT_EXHAUST_LEVEL2).publish_state(value);             });             queueRequest(Kessel, Property::kVENT_EXHAUST_LEVEL2);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kVENT_EXHAUST_LEVEL3),                                                       std::make_pair(Manager,Property::kVENT_EXHAUST_LEVEL3)},[](const SimpleVariant& value){                 id(VENT_EXHAUST_LEVEL3).publish_state(value);             });             queueRequest(Kessel, Property::kVENT_EXHAUST_LEVEL3);         - lambda: !lambda |-             // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_RUECKGE_TAG_WH),[](const SimpleVariant& value){               id(WAERMEERTRAG_RUECKGE_TAG_WH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_RUECKGE_TAG_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_RUECKGE_TAG_SUMME_KWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_RUECKGE_TAG_WH).state);             });             // initial queueing of the Wh and kWh value             queueRequest(Kessel, Property::kWAERMEERTRAG_RUECKGE_TAG_WH);             queueRequest(Kessel, Property::kWAERMEERTRAG_RUECKGE_TAG_KWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_WW_TAG_WH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_WW_TAG_WH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_WW_TAG_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_WW_TAG_SUMME_KWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_2WE_WW_TAG_WH).state);             });             // initial queueing of the Wh and kWh value             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_WW_TAG_WH);             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_WW_TAG_KWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_HEIZ_TAG_WH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_HEIZ_TAG_WH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_HEIZ_TAG_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_HEIZ_TAG_SUMME_KWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_2WE_HEIZ_TAG_WH).state);             });             // initial queueing of the Wh and kWh value             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_HEIZ_TAG_WH);             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_HEIZ_TAG_KWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Scaled property value is just stored in an internal sensor and published together with the property value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_RUECKGE_SUM_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_RUECKGE_SUM_KWH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_RUECKGE_SUM_MWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_RUECKGE_SUMME_MWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_RUECKGE_SUM_KWH).state);             });             // initial queueing of the values             queueRequest(Kessel, Property::kWAERMEERTRAG_RUECKGE_SUM_KWH);             queueRequest(Kessel, Property::kWAERMEERTRAG_RUECKGE_SUM_MWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Scaled property value is just stored in an internal sensor and published together with the property value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_WW_SUM_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_WW_SUM_KWH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_WW_SUM_MWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_WW_SUMME_MWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_2WE_WW_SUM_KWH).state);             });             // initial queueing of the values             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_WW_SUM_KWH);             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_WW_SUM_MWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Scaled property value is just stored in an internal sensor and published together with the property value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_HEIZ_SUM_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_HEIZ_SUM_KWH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_2WE_HEIZ_SUM_MWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_2WE_HEIZ_SUMME_MWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_2WE_HEIZ_SUM_KWH).state);             });             // initial queueing of the values             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_HEIZ_SUM_KWH);             queueRequest(Kessel, Property::kWAERMEERTRAG_2WE_HEIZ_SUM_MWH);         - lambda: !lambda |-             static_assert(Property::kWARMWASSER_ECO.type == Type::et_bool, "Only properties of type bool are supported by wp_switch.");                          CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kWARMWASSER_ECO),                                                       std::make_pair(Manager,Property::kWARMWASSER_ECO)}, [](const SimpleVariant& value){                 id(WARMWASSER_ECO).publish_state(value);             });             queueRequest(Kessel, Property::kWARMWASSER_ECO);         - lambda: !lambda |-             static_assert(Property::kKUEHLMODE.type == Type::et_bool, "Only properties of type bool are supported by wp_switch.");                          CallbackHandler::instance().addCallbacks({std::make_pair(HK1,Property::kKUEHLMODE),                                                       std::make_pair(Manager,Property::kKUEHLMODE)}, [](const SimpleVariant& value){                 id(KUEHLMODE).publish_state(value);             });             queueRequest(HK1, Property::kKUEHLMODE);         - lambda: !lambda |-             // Handle the values received from the heat pump. Scaled property value is just stored in an internal sensor and published together with the property value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kVERDICHTER_STARTS_K),[](const SimpleVariant& value){               id(VERDICHTER_STARTS_K).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kCOMPRESSOR_STARTS),[](const SimpleVariant& value){               id(COMPRESSOR_STARTS).publish_state(value.get<std::uint16_t>() + id(VERDICHTER_STARTS_K).state);             });             // initial queueing of the values             queueRequest(Kessel, Property::kVERDICHTER_STARTS_K);             queueRequest(Kessel, Property::kCOMPRESSOR_STARTS);         - lambda: !lambda |-             // Handle the values received from the heat pump. Scaled property value is just stored in an internal sensor and published together with the property value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_WW_SUM_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_WW_SUM_KWH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_WW_SUM_MWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_WW_SUMME_MWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_WW_SUM_KWH).state);             });             // initial queueing of the values             queueRequest(Kessel, Property::kWAERMEERTRAG_WW_SUM_KWH);             queueRequest(Kessel, Property::kWAERMEERTRAG_WW_SUM_MWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Scaled property value is just stored in an internal sensor and published together with the property value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_HEIZ_SUM_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_HEIZ_SUM_KWH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_HEIZ_SUM_MWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_HEIZ_SUMME_MWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_HEIZ_SUM_KWH).state);             });             // initial queueing of the values             queueRequest(Kessel, Property::kWAERMEERTRAG_HEIZ_SUM_KWH);             queueRequest(Kessel, Property::kWAERMEERTRAG_HEIZ_SUM_MWH);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(STORAGE_TEMP_SETPOINT).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSTORAGE_TEMP_SETPOINT),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kSTORAGE_TEMP_SETPOINT),callback);             }             queueRequest(Kessel, Property::kSTORAGE_TEMP_SETPOINT);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(STORAGE_TEMP_ACTUAL).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSTORAGE_TEMP_ACTUAL),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kSTORAGE_TEMP_ACTUAL),callback);             }             queueRequest(Kessel, Property::kSTORAGE_TEMP_ACTUAL);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(OUTSIDE_TEMP).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kOUTSIDE_TEMP),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kOUTSIDE_TEMP),callback);             }             queueRequest(Kessel, Property::kOUTSIDE_TEMP);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(RETURN_TEMP_ACTUAL).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kRETURN_TEMP_ACTUAL),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kRETURN_TEMP_ACTUAL),callback);             }             queueRequest(Kessel, Property::kRETURN_TEMP_ACTUAL);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(FLOW_TEMP_ACTUAL).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kFLOW_TEMP_ACTUAL),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kFLOW_TEMP_ACTUAL),callback);             }             queueRequest(HK1, Property::kFLOW_TEMP_ACTUAL);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(ROOM_TEMP_ACTUAL).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kROOM_TEMP_ACTUAL),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kROOM_TEMP_ACTUAL),callback);             }             queueRequest(HK1, Property::kROOM_TEMP_ACTUAL);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(ADJUSTED_ROOM_TEMP_SETPOINT).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kADJUSTED_ROOM_TEMP_SETPOINT),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kADJUSTED_ROOM_TEMP_SETPOINT),callback);             }             queueRequest(HK1, Property::kADJUSTED_ROOM_TEMP_SETPOINT);         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(FLOW_TEMP_SETPOINT).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kFLOW_TEMP_SETPOINT),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kFLOW_TEMP_SETPOINT),callback);             }             queueRequest(HK1, Property::kFLOW_TEMP_SETPOINT);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kFEHLERMELDUNG),[](const SimpleVariant& value){                 id(FEHLERMELDUNG).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kFEHLERMELDUNG);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kROOM_HUMIDITY),[](const SimpleVariant& value){                 id(ROOM_HUMIDITY).publish_state(1.0 * value.get<float>());             });             queueRequest(HK1, Property::kROOM_HUMIDITY);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(HK1,Property::kSLOPE_HC1),[](const SimpleVariant& value){                 id(SLOPE_HC1).publish_state(1.0 * value.get<float>());             });             queueRequest(HK1, Property::kSLOPE_HC1);         - lambda: !lambda |-             CallbackHandler::instance().addCallbacks({std::make_pair(HK1,Property::kRAUMEINFLUSS),                                                       std::make_pair(Manager,Property::kRAUMEINFLUSS)},[](const SimpleVariant& value){                 id(RAUMEINFLUSS).publish_state(value);             });             queueRequest(HK1, Property::kRAUMEINFLUSS);         - lambda: !lambda |-             // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEL_ENERGIEAUFNAHME_WW_TAG_WH),[](const SimpleVariant& value){               id(EL_ENERGIEAUFNAHME_WW_TAG_WH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEL_ENERGIEAUFNAHME_WW_TAG_KWH),[](const SimpleVariant& value){               id(EL_ENERGIEAUFNAHME_WW_SUMME_KWH).publish_state(value.get<std::uint16_t>() + id(EL_ENERGIEAUFNAHME_WW_TAG_WH).state);             });             // initial queueing of the Wh and kWh value             queueRequest(Kessel, Property::kEL_ENERGIEAUFNAHME_WW_TAG_WH);             queueRequest(Kessel, Property::kEL_ENERGIEAUFNAHME_WW_TAG_KWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEL_ENERGIEAUFNAHME_HEIZ_TAG_WH),[](const SimpleVariant& value){               id(EL_ENERGIEAUFNAHME_HEIZ_TAG_WH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEL_ENERGIEAUFNAHME_HEIZ_TAG_KWH),[](const SimpleVariant& value){               id(EL_ENERGIEAUFNAHME_HEIZ_SUMME_KWH).publish_state(value.get<std::uint16_t>() + id(EL_ENERGIEAUFNAHME_HEIZ_TAG_WH).state);             });             // initial queueing of the Wh and kWh value             queueRequest(Kessel, Property::kEL_ENERGIEAUFNAHME_HEIZ_TAG_WH);             queueRequest(Kessel, Property::kEL_ENERGIEAUFNAHME_HEIZ_TAG_KWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_WW_TAG_WH),[](const SimpleVariant& value){               id(WAERMEERTRAG_WW_TAG_WH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_WW_TAG_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_WW_TAG_SUMME_KWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_WW_TAG_WH).state);             });             // initial queueing of the Wh and kWh value             queueRequest(Kessel, Property::kWAERMEERTRAG_WW_TAG_WH);             queueRequest(Kessel, Property::kWAERMEERTRAG_WW_TAG_KWH);         - lambda: !lambda |-             // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_HEIZ_TAG_WH),[](const SimpleVariant& value){               id(WAERMEERTRAG_HEIZ_TAG_WH).publish_state(value.get<std::uint16_t>());             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWAERMEERTRAG_HEIZ_TAG_KWH),[](const SimpleVariant& value){               id(WAERMEERTRAG_HEIZ_TAG_SUMME_KWH).publish_state(value.get<std::uint16_t>() + id(WAERMEERTRAG_HEIZ_TAG_WH).state);             });             // initial queueing of the Wh and kWh value             queueRequest(Kessel, Property::kWAERMEERTRAG_HEIZ_TAG_WH);             queueRequest(Kessel, Property::kWAERMEERTRAG_HEIZ_TAG_KWH);         - lambda: !lambda |-             id(HEATPUMP_DATETIME).state = "2024-01-01 12:34";             auto updateTime = [](auto&& updateTimeFragment){                 ESPTime timeToSet{};                 // get the datetime as string and parse to ESPTime object                 if(const auto success = ESPTime::strptime(id(HEATPUMP_DATETIME).state, timeToSet); !success) {                   ESP_LOGE("DATETIME", "Error parsing datetime string %s", id(HEATPUMP_DATETIME).state.c_str());                   return;                 }                 // update the part that belongs to this sensor                 updateTimeFragment(timeToSet);                 // convert the time back to string and directly save it to the state of the datetime sensor                 char buf[20];                 timeToSet.strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M");                 // publish the value                 id(HEATPUMP_DATETIME).state = std::string(buf);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kJAHR),[updateTime](const SimpleVariant& value){               updateTime([&value](ESPTime& timeToSet){                 timeToSet.year = 2000U + static_cast<std::uint16_t>(value);               });             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kMONAT),[updateTime](const SimpleVariant& value){               updateTime([&value](ESPTime& timeToSet){                 timeToSet.month = static_cast<std::uint16_t>(value);               });             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kWOCHENTAG),[](const SimpleVariant&){});             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kTAG),[updateTime](const SimpleVariant& value){               updateTime([&value](ESPTime& timeToSet){                 timeToSet.day_of_month = static_cast<std::uint16_t>(value);               });             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSTUNDE),[updateTime](const SimpleVariant& value){               updateTime([&value](ESPTime& timeToSet){                 timeToSet.hour = static_cast<std::uint16_t>(value);               });             });             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kMINUTE),[updateTime](const SimpleVariant& value){               updateTime([&value](ESPTime& timeToSet){                 timeToSet.minute = static_cast<std::uint16_t>(value);               });               id(HEATPUMP_DATETIME).publish_state(id(HEATPUMP_DATETIME).state);             });             queueRequest(Kessel, Property::kJAHR);             queueRequest(Kessel, Property::kMONAT);             queueRequest(Kessel, Property::kTAG);             queueRequest(Kessel, Property::kSTUNDE);             queueRequest(Kessel, Property::kMINUTE);         - [source yaml\wp_temperature.yaml:25]                      Couldn't find ID 'PASSIVE_COOLING'. Please check you have defined an ID with that name in your configuration. These IDs look similar: "PASSIVKUEHLUNG".           lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kPASSIVE_COOLING),[](const SimpleVariant& value){               const auto stringValue{Mapper::instance().getPassivkuehlung(value).value_or("Unbekannt")};               const auto index = id(PASSIVE_COOLING).index_of(stringValue);               if(index.has_value()) {                 id(PASSIVE_COOLING).publish_state(stringValue);               }             });             scheduleRequest(Kessel, Property::kPASSIVE_COOLING, std::chrono::seconds(10));                          CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kSUPPLY_AIR_ACTUAL),[](const SimpleVariant& value){               // workaround for broken ninth bit of BETRIEBSSTATUS               const auto zuluftIst = static_cast<std::uint16_t>(value);               id(VENTILATION).publish_state(zuluftIst > 0U);             });             scheduleRequest(Kessel, Property::kSUPPLY_AIR_ACTUAL, std::chrono::seconds(10));                          CallbackHandler::instance().addCallbacks({std::make_pair(Kessel,Property::kEXHAUST_AIR_SETPOINT),                                                       std::make_pair(Kessel,Property::kSUPPLY_AIR_SETPOINT)},                                                       [](const SimpleVariant&) {               const auto airflowIn{id(SUPPLY_AIR_SETPOINT).state};               const auto airflowOut{id(EXHAUST_AIR_SETPOINT).state};               auto getPower = [](const float airflow){                 if(airflow < 0.1f) {                   return 0.0f;                 }                 /* This equation is base on the following measurement:                  * airflow (l/min)       : 0 140 190 220 300                  * combined fan power (W): 0  30  50  80 170                  * @note: the last value is taken as from the THZ504 specification.                  */                 return (0.00005f * std::pow(airflow, 2.5f) + 3.0f);               };               id(FAN_POWER).publish_state(getPower(airflowIn) + getPower(airflowOut));             });                          id(ELEKTRISCHE_NACHERWAERMUNG).add_on_state_callback([](const bool state){               const auto electricHeatingPower = state ? id(NE_STUFE_WW).state * 230.0 /*V*/ * 12.6 /*A*/ : 0.0f;               id(ELECTRIC_HEATING_POWER).publish_state(electricHeatingPower);             });                          CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kPROGRAMMSCHALTER),[](const SimpleVariant& value){               const auto stringValue{value.get<std::string>()};               const auto index = id(PROGRAMMSCHALTER).index_of(stringValue);               if(index.has_value()) {                 id(PROGRAMMSCHALTER).publish_state(stringValue);               }             });             scheduleRequest(Kessel, Property::kPROGRAMMSCHALTER, std::chrono::seconds(10));                          CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kBETRIEBS_STATUS_2),[](const SimpleVariant& value){               const std::bitset<2U> status_bits{static_cast<std::uint16_t>(value)};               id(SUMMER_MODE_ACTIVE).publish_state(status_bits.test(0U));               id(OFEN_KAMIN_AKTIV).publish_state(status_bits.test(1U));             });             scheduleRequest(Kessel, Property::kBETRIEBS_STATUS_2, std::chrono::seconds(10));                          CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kBETRIEBS_STATUS),[](const SimpleVariant& value){               const std::bitset<15U> status_bits{static_cast<std::uint16_t>(value)};               id(SCHALTPROGRAMM_AKTIV).publish_state(status_bits.test(0U));               id(COMPRESSOR).publish_state(status_bits.test(1U));               id(HEATING).publish_state(status_bits.test(2U));               id(COOLING).publish_state(status_bits.test(3U));               id(DHW_HEATING).publish_state(status_bits.test(4U));               id(ELEKTRISCHE_NACHERWAERMUNG).publish_state(status_bits.test(5U));               id(SERVICE).publish_state(status_bits.test(6U));               id(EVU_SPERRE).publish_state(status_bits.test(7U));               id(FILTERWECHSEL_BEIDE).publish_state(status_bits.test(8U));               // seems to be broken id(VENTILATION).publish_state(status_bits.test(9U));               id(HEIZKREISPUMPE).publish_state(status_bits.test(10U));               id(ABTAUEN_VERDAMPFER).publish_state(status_bits.test(11U));               id(FILTERWECHSEL_ABLUFT).publish_state(status_bits.test(12U));               id(FILTERWECHSEL_ZULUFT).publish_state(status_bits.test(13U));               id(AUFHEIZPROGRAMM_AKTIV).publish_state(status_bits.test(14U));             });             scheduleRequest(Kessel, Property::kBETRIEBS_STATUS, std::chrono::seconds(10)); [source yaml\wp_base.yaml:7]         - lambda: !lambda |-             auto callback= [](const SimpleVariant& value){                 id(EXHAUST_AIR_DEWPOINT).publish_state(value);             };             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kEXHAUST_AIR_DEWPOINT),callback);             if constexpr(false) {               CallbackHandler::instance().addCallback(std::make_pair(Manager,Property::kEXHAUST_AIR_DEWPOINT),callback);             }             queueRequest(Kessel, Property::kEXHAUST_AIR_DEWPOINT);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kDIFFERENZDRUCK),[](const SimpleVariant& value){                 id(DIFFERENZDRUCK).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kDIFFERENZDRUCK);         - lambda: !lambda |-             CallbackHandler::instance().addCallback(std::make_pair(Kessel,Property::kLAUFZEIT_FILTER_TAGE),[](const SimpleVariant& value){                 id(LAUFZEIT_FILTER_TAGE).publish_state(1.0 * value.get<float>());             });             queueRequest(Kessel, Property::kLAUFZEIT_FILTER_TAGE);         - light.turn_on:              id: status_rgb_led             brightness: 0.5             red: 0.0             green: 0.0             blue: 1.0             state: True         - delay: 3s   name: heatingpump   friendly_name: ESP32-C6 THZ-504   min_version: 2025.5.1   build_path: build\heatingpump   area: ''   libraries: []   name_add_mac_suffix: False   debug_scheduler: False Couldn't find ID 'SUMMER_MODE_ACTIVE'. Please check you have defined an ID with that name in your configuration.  Couldn't find ID 'HEATING'. Please check you have defined an ID with that name in your configuration. These IDs look similar: "HEIZEN".  Couldn't find ID 'COOLING'. Please check you have defined an ID with that name in your configuration.  Couldn't find ID 'DHW_HEATING'. Please check you have defined an ID with that name in your configuration. 
[2025-09-28 23:07:22] === OPERATION SUMMARY ===
[2025-09-28 23:07:22] Config File: esp32-c6-thz504.yaml
[2025-09-28 23:07:22] Device IP:   192.168.200.80
[2025-09-28 23:07:22] Project:     C:\dev\repos\OneESP32ToRuleThemAll
[2025-09-28 23:07:22] 
[2025-09-28 23:07:22] Compilation: FAILED
[2025-09-28 23:07:22] 
[2025-09-28 23:07:22] Log file: C:\dev\repos\OneESP32ToRuleThemAll\upload-log.txt
